# 简述原型与原型链

> 在 JavaScript 中，函数可以有属性。 每个函数都有一个特殊的属性叫作原型（prototype）。

通常，我们会通过构造函数对原型进行操作：

```js
function Foo() {}

console.log(Foo.prototype) // {constructor: ƒ}
```

打印出来的对象就是`Foo`函数的原型，将其展开，发现里面有两个属性`constructor`和`__proto__`。`constructor`指向`Foo`函数本身，`__proto__`是一个对象。

可以在函数的原型上添加一些其他属性，比如：

```js
Foo.prototype.name = 'nick'
Foo.prototype.age = 18
```

再次查看`Foo`的原型：

```js
console.log(Foo.prototype)
```

发现刚刚添加的`name`与`age`已经在原型中了。

现在创建一个`Foo`的实例：

```js
var foo = new Foo()
```

将其打印，发现里面有一个`__proto__`属性，而这个属性里面包含了之前在构造函数`Foo`的原型中创建的`name`和`age`属性。也就是说，构造函数的实例都可以通过`__proto__`属性找到创建它的构造函数的原型对象。

由此可以得到下面这张关系图：
![实例与构造函数](https://tva1.sinaimg.cn/large/008eGmZEly1gnzut9cnldj30nu0ckmxy.jpg)

在之前打印`Foo`的原型时，发现里面的`__proto__`是一个对象，将其展开，发现有一个`constructor`属性是指向`Object`构造函数的。那么`Foo`原型上的`__proto__`会不会就是构造函数`Object`的原型呢？

带着疑问，试着打印对比一下：

```js
console.log(Foo.prototype.__proto__ === Object.prototype) // true
```

结果为`true`。并且我们知道在`JavaScript`中，函数都有一个特殊的属性`prototype`，那么构造函数`Object`的内部结构与之前创建的构造函数`Foo`的内部结构是差不多的。

现在再来更新一下刚刚的关系图：
![Object与其他构造函数](https://tva1.sinaimg.cn/large/008eGmZEly1gnzvh5umkpj30o80k0myp.jpg)

可以看出，函数的`__proto__`属性就像一根线条一样一直往上衔接，那么问题又来了？`Object`原型上的`__proto__`又是个啥？会不会是其他构造函数的原型？

带着疑问，再次打印看看结果：

```js
console.log(Object.prototype.__proto__) // null
```

结果是一个特殊值`null`，这就表明，原型链的最顶层就是到构造函数`Object`原型的`__proto__`，也就是`null`。

更新一下刚才的关系图：

![原型链顶层](https://tva1.sinaimg.cn/large/008eGmZEly1gnzwoxdldjj30pi0smgnh.jpg)

到这里，基本上把原型与原型链的关系理清楚了。但是，函数的原型又是从哪里来的呢？

要下班了，回家继续写...